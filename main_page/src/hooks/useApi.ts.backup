import { useState, useEffect } from 'react';
import { apiService, ApiQuestion, ApiAnswerResp// API ì§ˆë¬¸ì„ ë¡œì»¬ Question íƒ€ì…ìœ¼ë¡œ ë³€í™˜
const convertApiQuestionToLocal = async (apiQuestion: ApiQuestion): Promise<Question> => {
  console.log('Converting API question:', apiQuestion); // ë””ë²„ê¹…ìš©
  
  // ì§ˆë¬¸ì˜ ì‹¤ì œ ì¢‹ì•„ìš” ìˆ˜ë¥¼ ê°€ì ¸ì˜¤ê¸°
  let actualLikes = apiQuestion.total_votes; // ê¸°ë³¸ê°’
  try {
    const likesData = await apiService.getQuestionLikes(apiQuestion._id);
    console.log('Question likes data:', likesData);
    // API ì‘ë‹µ êµ¬ì¡°ì— ë”°ë¼ ì‹¤ì œ ì¢‹ì•„ìš” ìˆ˜ ì¶”ì¶œ
    if (likesData && typeof likesData.total_votes === 'number') {
      actualLikes = likesData.total_votes;
    }
  } catch (err) {
    console.warn('Failed to fetch question likes:', err);
    // ì‹¤íŒ¨ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©
  }
  
  return {
    id: apiQuestion._id,
    question: apiQuestion.title,
    likes: actualLikes,
    timeAgo: formatTimeAgo(apiQuestion.created_at),
    isNew: apiQuestion.status === 'unanswered',
  };
};tQuestionResponse, InvalidQuestionResponse, SimilarQuestion } from '../services/api';
import { Question, Answer } from '../data/qnaData';

// ì‹œê°„ í¬ë§·íŒ… ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ - ì‹œê°„ëŒ€ ì°¨ì´ ê³ ë ¤ (ê°œì„ ëœ ë²„ì „)
const formatTimeAgo = (dateString: string): string => {
  try {
    // í˜„ì¬ ì‹œê°„ì„ í•œêµ­ ì‹œê°„ëŒ€ë¡œ ê°€ì ¸ì˜¤ê¸°
    const now = new Date();
    const created = new Date(dateString);
    
    // ìœ íš¨í•œ ë‚ ì§œì¸ì§€ í™•ì¸
    if (isNaN(created.getTime())) {
      console.warn('Invalid date string:', dateString);
      return 'ì‹œê°„ ì •ë³´ ì—†ìŒ';
    }
    
    // ì„œë²„ê°€ UTC ì‹œê°„ì„ ë³´ë‚´ê³  ìˆë‹¤ê³  ê°€ì •
    // ì„œë²„ ì‹œê°„ì´ ì´ë¯¸ UTC+9 (í•œêµ­ì‹œê°„)ì¸ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë‘ ê°€ì§€ ë°©ë²• ëª¨ë‘ ì‹œë„
    
    // ë°©ë²• 1: ì„œë²„ ì‹œê°„ì„ UTCë¡œ ê°„ì£¼í•˜ê³  í•œêµ­ ì‹œê°„ê³¼ ë¹„êµ
    const createdAsUTC = new Date(dateString + (dateString.includes('Z') ? '' : 'Z'));
    const diffMethod1 = now.getTime() - createdAsUTC.getTime();
    
    // ë°©ë²• 2: ì„œë²„ ì‹œê°„ì„ ì´ë¯¸ í•œêµ­ ì‹œê°„ìœ¼ë¡œ ê°„ì£¼
    const diffMethod2 = now.getTime() - created.getTime();
    
    // 9ì‹œê°„ ì°¨ì´ê°€ ë‚˜ëŠ”ì§€ í™•ì¸í•´ì„œ ì–´ë–¤ ë°©ë²•ì„ ì‚¬ìš©í• ì§€ ê²°ì •
    const nineHoursInMs = 9 * 60 * 60 * 1000;
    const diff1Hours = Math.abs(diffMethod1 / (60 * 60 * 1000));
    const diff2Hours = Math.abs(diffMethod2 / (60 * 60 * 1000));
    
    // ë” í•©ë¦¬ì ì¸ ì‹œê°„ ì°¨ì´ë¥¼ ì„ íƒ (24ì‹œê°„ ì´ë‚´ê°€ ë” í•©ë¦¬ì )
    let diffInMilliseconds;
    if (Math.abs(diffMethod1) < Math.abs(diffMethod2) && diff1Hours < 24) {
      diffInMilliseconds = diffMethod1;
      console.log('Using Method 1 (UTC conversion)');
    } else if (diff2Hours < 24) {
      diffInMilliseconds = diffMethod2;
      console.log('Using Method 2 (direct comparison)');
    } else {
      // ë‘˜ ë‹¤ 24ì‹œê°„ ì´ìƒì´ë©´ UTC ë³€í™˜ ë°©ì‹ ì‚¬ìš©
      diffInMilliseconds = diffMethod1;
      console.log('Using Method 1 (fallback)');
    }
    
    const diffInSeconds = Math.floor(Math.abs(diffInMilliseconds) / 1000);
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    const diffInHours = Math.floor(diffInMinutes / 60);
    const diffInDays = Math.floor(diffInHours / 24);
    const diffInWeeks = Math.floor(diffInDays / 7);
    const diffInMonths = Math.floor(diffInDays / 30);
    
    // ë””ë²„ê¹…ìš© ë¡œê·¸
    console.log('Time calculation with timezone (v2):', {
      originalDate: dateString,
      now: now.toISOString(),
      nowLocal: now.toLocaleString('ko-KR'),
      created: created.toISOString(),
      createdAsUTC: createdAsUTC.toISOString(),
      diffMethod1Hours: diff1Hours,
      diffMethod2Hours: diff2Hours,
      selectedDiffHours: diffInHours,
      diffInSeconds,
      diffInMinutes,
      diffInHours,
      diffInDays
    });
    
    // ì‹œê°„ êµ¬ê°„ë³„ í¬ë§·íŒ…
    if (diffInSeconds < 60) {
      return 'ë°©ê¸ˆ ì „';
    } else if (diffInMinutes < 60) {
      return `${diffInMinutes}ë¶„ ì „`;
    } else if (diffInHours < 24) {
      return `${diffInHours}ì‹œê°„ ì „`;
    } else if (diffInDays < 7) {
      return `${diffInDays}ì¼ ì „`;
    } else if (diffInWeeks < 4) {
      return `${diffInWeeks}ì£¼ ì „`;
    } else if (diffInMonths < 12) {
      return `${diffInMonths}ê°œì›” ì „`;
    } else {
      return `${Math.floor(diffInMonths / 12)}ë…„ ì „`;
    }
  } catch (error) {
    console.error('Error formatting time:', error, 'dateString:', dateString);
    return 'ì‹œê°„ ì •ë³´ ì˜¤ë¥˜';
  }
};

// API ë°ì´í„°ë¥¼ ë¡œì»¬ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
const convertApiQuestionToLocal = (apiQuestion: ApiQuestion): Question => {
  console.log('Converting API question:', apiQuestion); // ë””ë²„ê¹…ìš©
  
  return {
    id: apiQuestion._id,
    question: apiQuestion.title,
    fires: apiQuestion.total_votes,
    timeAgo: formatTimeAgo(apiQuestion.created_at),
    isNew: apiQuestion.status === 'unanswered',
  };
};

// ìƒˆë¡œìš´ ë‹µë³€ API ì‘ë‹µì„ Answer íƒ€ì…ìœ¼ë¡œ ë³€í™˜
const convertApiAnswerResponseToLocal = async (apiAnswerResponse: ApiAnswerResponse): Promise<Answer> => {
  console.log('Converting API answer response:', apiAnswerResponse); // ë””ë²„ê¹…ìš©
  
  // ë‹µë³€ì˜ ì‹¤ì œ ì¢‹ì•„ìš” ìˆ˜ë¥¼ ê°€ì ¸ì˜¤ê¸°
  let actualLikes = apiAnswerResponse.answer.total_votes; // ê¸°ë³¸ê°’
  try {
    const likesData = await apiService.getAnswerLikes(apiAnswerResponse.answer._id);
    console.log('Answer likes data:', likesData);
    // API ì‘ë‹µ êµ¬ì¡°ì— ë”°ë¼ ì‹¤ì œ ì¢‹ì•„ìš” ìˆ˜ ì¶”ì¶œ
    if (likesData && typeof likesData.total_votes === 'number') {
      actualLikes = likesData.total_votes;
    }
  } catch (err) {
    console.warn('Failed to fetch answer likes:', err);
    // ì‹¤íŒ¨ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©
  }
  
  return {
    id: apiAnswerResponse.answer._id,
    question: apiAnswerResponse.question.title,
    answer: apiAnswerResponse.answer.content,
    likes: actualLikes,
    timeAgo: formatTimeAgo(apiAnswerResponse.answer.created_at),
  };
};

// ìµœê·¼ ë‹µë³€ì„ ê°€ì ¸ì˜¤ëŠ” í›… (ìƒˆë¡œìš´ ë‹µë³€ API ì‚¬ìš©)
export const useRecentAnswers = (skip: number = 0, limit: number = 3) => {
  const [answers, setAnswers] = useState<Answer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);

  const fetchAnswers = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiService.getRecentAnswers(skip, limit);
      const convertedAnswers = await Promise.all(
        response.map(apiResponse => convertApiAnswerResponseToLocal(apiResponse))
      );
      setAnswers(convertedAnswers);
      setTotal(response.length);
    } catch (err) {
      console.error('Error fetching answers:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch answers');
    } finally {
      setLoading(false);
    }
  };  useEffect(() => {
    fetchAnswers();
  }, [skip, limit]);

  return { answers, loading, error, total, refetch: fetchAnswers };
};

// ì¸ê¸° ì§ˆë¬¸ì„ ê°€ì ¸ì˜¤ëŠ” í›…
export const useHotQuestions = (skip: number = 0, limit: number = 4) => {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);

  const fetchQuestions = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiService.getHotQuestions(skip, limit);
      const convertedQuestions = response.map(convertApiQuestionToLocal);
      setQuestions(convertedQuestions);
      setTotal(response.length); // ì‹¤ì œ totalì€ ë³„ë„ API ë˜ëŠ” í—¤ë”ì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
    } catch (err) {
      setError(err instanceof Error ? err.message : 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      console.error('Failed to fetch hot questions:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchQuestions();
  }, [skip, limit]);

  return { questions, loading, error, total, refetch: fetchQuestions };
};

// ëŒ€í‘œ ì§ˆë¬¸ì„ ê°€ì ¸ì˜¤ëŠ” í›…
export const useRepresentativeQuestions = (skip: number = 0, limit: number = 10) => {
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);

  const fetchQuestions = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiService.getRepresentativeQuestions(skip, limit);
      const convertedQuestions = response.map(convertApiQuestionToLocal);
      setQuestions(convertedQuestions);
      setTotal(response.length); // ì‹¤ì œ totalì€ ë³„ë„ API ë˜ëŠ” í—¤ë”ì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
    } catch (err) {
      setError(err instanceof Error ? err.message : 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      console.error('Failed to fetch representative questions:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchQuestions();
  }, [skip, limit]);

  return { questions, loading, error, total, refetch: fetchQuestions };
};

// ì§ˆë¬¸ ì œì¶œ í›… - ìƒˆë¡œìš´ API ìŠ¤í™ ëŒ€ì‘
export const useSubmitQuestion = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [similarQuestion, setSimilarQuestion] = useState<SimilarQuestion | null>(null);
  const [showSimilarQuestion, setShowSimilarQuestion] = useState(false);

  const submitQuestion = async (content: string, force: boolean = false): Promise<{
    success: boolean;
    status?: "new_question_submitted" | "similar_question_found" | "invalid_question";
    message?: string;
  }> => {
    try {
      setLoading(true);
      setError(null);
      setSimilarQuestion(null);
      setShowSimilarQuestion(false);
      
      const response = await apiService.submitQuestion(content, force);
      
      // ë¶€ì ì ˆí•œ ì§ˆë¬¸ ì‘ë‹µ ì²˜ë¦¬
      if ('detail' in response) {
        const invalidResponse = response as InvalidQuestionResponse;
        setError(invalidResponse.detail);
        return { 
          success: false, 
          status: "invalid_question", 
          message: invalidResponse.detail 
        };
      }
      
      // ì •ìƒ ì‘ë‹µ ì²˜ë¦¬
      const validResponse = response as SubmitQuestionResponse;
      
      if (validResponse.status === "similar_question_found") {
        setSimilarQuestion(validResponse.similar_question);
        setShowSimilarQuestion(true);
        return {
          success: false,
          status: "similar_question_found",
          message: validResponse.message
        };
      } else if (validResponse.status === "new_question_submitted") {
        return {
          success: true,
          status: "new_question_submitted",
          message: validResponse.message
        };
      }
      
      return { success: false, message: "ì•Œ ìˆ˜ ì—†ëŠ” ì‘ë‹µ í˜•ì‹ì…ë‹ˆë‹¤." };
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'ì§ˆë¬¸ ì œì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      setError(errorMessage);
      console.error('Failed to submit question:', err);
      return { success: false, message: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  const submitWithForce = (content: string) => {
    return submitQuestion(content, true);
  };

  const dismissSimilarQuestion = () => {
    setShowSimilarQuestion(false);
    setSimilarQuestion(null);
  };

  return { 
    submitQuestion, 
    submitWithForce,
    loading, 
    error, 
    similarQuestion,
    showSimilarQuestion,
    dismissSimilarQuestion
  };
};

// ì¢‹ì•„ìš” ê¸°ëŠ¥ í›…
export const useLike = () => {
  const [loading, setLoading] = useState<string | null>(null); // í˜„ì¬ ë¡œë”© ì¤‘ì¸ ì•„ì´í…œ ID
  const [error, setError] = useState<string | null>(null);

  const likeQuestion = async (questionId: string): Promise<boolean> => {
    try {
      console.log('ğŸ”¥ likeQuestion called with ID:', questionId); // ë””ë²„ê¹… ë¡œê·¸
      setLoading(questionId);
      setError(null);
      await apiService.likeQuestion(questionId);
      console.log('âœ… ì§ˆë¬¸ ì¢‹ì•„ìš” ì„±ê³µ:', questionId);
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'ì¢‹ì•„ìš” ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      setError(errorMessage);
      console.error('âŒ Failed to like question:', questionId, err);
      return false;
    } finally {
      setLoading(null);
    }
  };

  const likeAnswer = async (answerId: string): Promise<boolean> => {
    try {
      console.log('ğŸ”¥ likeAnswer called with ID:', answerId); // ë””ë²„ê¹… ë¡œê·¸
      setLoading(answerId);
      setError(null);
      await apiService.likeAnswer(answerId);
      console.log('âœ… ë‹µë³€ ì¢‹ì•„ìš” ì„±ê³µ:', answerId);
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'ì¢‹ì•„ìš” ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      setError(errorMessage);
      console.error('âŒ Failed to like answer:', answerId, err);
      return false;
    } finally {
      setLoading(null);
    }
  };

  const isLoading = (itemId: string): boolean => {
    return loading === itemId;
  };

  return { likeQuestion, likeAnswer, isLoading, error };
};
